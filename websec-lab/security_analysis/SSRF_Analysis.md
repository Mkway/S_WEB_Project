# SSRF (Server-Side Request Forgery) 분석 보고서

## 1. SSRF 란?

**서버를 대신하여 원하는 곳에 요청을 보내다**

- **SSRF란?** Server-Side Request Forgery의 약자로, 공격자가 서버를 속여서 서버 자신이나 내부망, 또는 다른 외부 서버로 임의의 요청을 보내게 만드는 공격 기법입니다.
- **원리:** 웹 애플리케이션이 사용자로부터 URL을 입력받아 해당 URL의 리소스를 가져오거나 처리하는 기능(예: 이미지 URL로 썸네일 생성, 웹훅 알림)에서, 입력된 URL을 제대로 검증하지 않을 때 발생합니다.
- **영향:**
    - **내부 시스템 정보 유출:** 외부에서 접근할 수 없는 내부망의 관리자 페이지, API 서버 등에 접근하여 정보를 탈취합니다.
    - **내부망 스캔:** 서버를 프록시처럼 사용하여 내부 네트워크의 다른 서버와 포트를 스캔하고, 시스템 구조를 파악합니다.
    - **클라우드 자격 증명 탈취:** AWS, GCP 등 클라우드 환경의 메타데이터 서비스에 접근하여 임시 자격 증명을 훔치고, 클라우드 계정을 장악할 수 있습니다.
    - **로컬 파일 읽기:** `file://` 프로토콜을 이용하여 서버의 로컬 파일을 읽을 수 있습니다.

---

## 2. 취약한 코드 분석 (예시)

**문제의 핵심: 사용자 입력 URL의 무결성 검증 부재**

```php
// 사용자가 URL 파라미터로 전달한 이미지 주소
$url = $_GET['url'];

// 취약한 코드
// 애플리케이션은 사용자가 제공한 URL의 내용을 그대로 가져옵니다.
$image_data = file_get_contents($url);

// 가져온 데이터를 이미지로 출력
header('Content-Type: image/jpeg');
echo $image_data;
```

**핵심 문제점:** 사용자가 제공한 URL이 정말로 외부의 이미지 파일인지, 아니면 내부 시스템을 가리키는 주소인지 전혀 검증하지 않는 것이 문제입니다.

---

## 3. 공격 시나리오 1: 내부 관리자 페이지 접근

**공격 목표:** 외부에서 접근할 수 없는 내부 관리자 페이지(`http://localhost/admin`)에 접근하기

**공격 페이로드:** `http://victim.com/get_image.php?url=http://localhost/admin`

**공격 과정:**
1.  공격자는 `url` 파라미터 값으로 내부망 주소인 `http://localhost/admin`을 전달합니다.
2.  취약한 서버는 이 요청을 받고, 자기 자신(`localhost`)의 `/admin` 페이지로 HTTP 요청을 보냅니다.
3.  서버 자신에게는 `/admin` 페이지가 접근 가능하므로, 해당 페이지의 HTML 내용을 성공적으로 가져옵니다.
4.  서버는 가져온 HTML 내용을 공격자에게 응답으로 전달하고, 공격자는 이를 통해 내부 관리자 페이지의 내용을 확인할 수 있습니다.

---

## 4. 공격 시나리오 2: 클라우드 인스턴스 정보 탈취

**공격 목표:** AWS EC2 인스턴스의 메타데이터 서비스를 이용하여 임시 자격 증명 탈취하기

**공격 페이로드:** `http://victim.com/get_image.php?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/admin-role`

**공격 과정:**
1.  `169.254.169.254`는 AWS EC2 인스턴스가 자신의 정보를 얻기 위해 사용하는 특수한 내부 IP 주소입니다.
2.  공격자는 `url` 파라미터에 메타데이터 서비스의 특정 경로를 포함하여 요청을 보냅니다.
3.  EC2 위에서 동작하는 취약한 서버는 이 요청을 받고, 메타데이터 서비스에 `admin-role`의 임시 자격 증명을 요청합니다.
4.  메타데이터 서비스는 요청이 내부에서 왔으므로 유효하다고 판단하고, Access Key, Secret Key, Token을 반환합니다.
5.  공격자는 이 자격 증명을 이용하여 해당 AWS 계정에 접근할 수 있게 됩니다.

---

## 5. 해결책: 화이트리스트 및 IP 주소 검증

**가장 안전한 방법: 다단계 방어 전략 수립**

```php
// 사용자가 입력한 URL
$url = $_GET['url'];

// 1. URL 파싱하여 구성 요소 분리
$url_parts = parse_url($url);

// 2. 프로토콜(Scheme) 화이트리스트 검증
if (!in_array($url_parts['scheme'], ['http', 'https'])) {
    die('허용되지 않은 프로토콜입니다.');
}

// 3. 호스트(Domain) 화이트리스트 검증
$allowed_domains = ['images.example.com', 'api.example.com'];
if (!in_array($url_parts['host'], $allowed_domains)) {
    die('허용되지 않은 도메인입니다.');
}

// 4. 도메인을 IP 주소로 변환
$ip = gethostbyname($url_parts['host']);

// 5. 변환된 IP가 내부망/예약 대역이 아닌지 확인
if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) === false) {
    die('내부 IP 대역으로의 요청은 허용되지 않습니다.');
}

// 모든 검증을 통과한 경우에만 요청 실행
$data = file_get_contents($url);
```

**작동 원리:** 이 다단계 방어 로직은 서버가 오직 허용된 도메인으로만 요청을 보내도록 강제하며, DNS Rebinding 같은 우회 공격을 막기 위해 최종 IP 주소까지 검증하여 내부망으로의 접근을 원천적으로 차단합니다.

---

## 6. SSRF 방어 전략

1.  **URL 화이트리스트 사용 (가장 중요):** 요청을 보낼 수 있는 도메인과 프로토콜 목록을 만들어, 이 목록에 있는 URL만 허용합니다.
2.  **사용자 입력값 검증 및 정제:** URL 구조를 분석하여 비정상적인 부분이 없는지 확인합니다.
3.  **사용하지 않는 URL 스키마 비활성화:** `http`, `https` 외에 `file://`, `gopher://`, `ftp://` 등 불필요한 프로토콜은 라이브러리 레벨에서 비활성화합니다.
4.  **네트워크 분리:** 외부와 통신하는 서버는 내부망의 다른 중요 서버들과 물리적/논리적으로 분리하여 피해 범위를 최소화합니다.
5.  **프록시 서버 사용:** 모든 외부 요청을 전용 프록시 서버를 통해 내보내도록 구성하여, 접근 제어를 중앙에서 관리합니다.
