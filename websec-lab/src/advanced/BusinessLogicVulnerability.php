<?php
/**
 * Business Logic Vulnerability Test Module
 * 
 * 비즈니스 로직 취약점을 테스트하는 모듈
 * - Price Manipulation (가격 조작)
 * - Quantity Bypass (수량 제한 우회)
 * - Discount Abuse (할인 남용)
 * - Workflow Bypass (워크플로우 우회)
 * - Race Condition (경쟁 조건)
 */

class BusinessLogicVulnerability {
    private $userId;
    private $balance;
    private $cart = [];
    private $discountUsed = false;
    
    // 가상 상품 데이터
    private $products = [
        1 => ['name' => 'Premium Software License', 'price' => 299.99, 'stock' => 10],
        2 => ['name' => 'Cloud Storage 1TB', 'price' => 99.99, 'stock' => 50],
        3 => ['name' => 'Digital Certificate', 'price' => 199.99, 'stock' => 5],
        4 => ['name' => 'API Access Token', 'price' => 49.99, 'stock' => 100]
    ];
    
    public function __construct($userId = 1, $initialBalance = 1000.00) {
        $this->userId = $userId;
        $this->balance = $initialBalance;
    }
    
    // ==================== 취약한 비즈니스 로직 ====================
    
    /**
     * 취약한 가격 계산 (Price Manipulation)
     * 
     * @param int $productId 상품 ID
     * @param int $quantity 수량
     * @param float $customPrice 사용자 지정 가격 (취약점)
     * @return array
     */
    public function vulnerableAddToCart($productId, $quantity, $customPrice = null) {
        if (!isset($this->products[$productId])) {
            return ['success' => false, 'message' => '존재하지 않는 상품입니다.'];
        }
        
        $product = $this->products[$productId];
        
        // 취약점: 사용자가 지정한 가격을 검증 없이 사용
        $price = $customPrice !== null ? $customPrice : $product['price'];
        
        // 취약점: 수량 제한 없음 (음수 가능)
        $totalPrice = $price * $quantity;
        
        $this->cart[] = [
            'product_id' => $productId,
            'name' => $product['name'],
            'quantity' => $quantity,
            'unit_price' => $price,
            'total_price' => $totalPrice
        ];
        
        return [
            'success' => true, 
            'message' => '장바구니에 추가되었습니다.',
            'cart_total' => $this->calculateCartTotal(),
            'manipulation' => $customPrice !== null ? 'PRICE_MANIPULATED' : 'NORMAL'
        ];
    }
    
    /**
     * 취약한 할인 적용 (Discount Abuse)
     * 
     * @param string $discountCode 할인 코드
     * @param float $discountAmount 할인 금액 (사용자 입력)
     * @return array
     */
    public function vulnerableApplyDiscount($discountCode, $discountAmount = null) {
        // 취약점: 할인 중복 적용 체크 없음
        // 취약점: 사용자가 할인 금액을 직접 지정 가능
        
        $validCodes = ['SAVE10' => 10, 'WELCOME20' => 20, 'PREMIUM50' => 50];
        
        if (isset($validCodes[$discountCode])) {
            // 정상적인 할인
            $discount = $validCodes[$discountCode];
        } elseif ($discountAmount !== null) {
            // 취약점: 사용자 지정 할인 금액 허용
            $discount = $discountAmount;
        } else {
            return ['success' => false, 'message' => '잘못된 할인 코드입니다.'];
        }
        
        $cartTotal = $this->calculateCartTotal();
        $discountedTotal = $cartTotal - $discount;
        
        // 취약점: 음수 총액 허용
        $finalTotal = $discountedTotal;
        
        return [
            'success' => true,
            'message' => '할인이 적용되었습니다.',
            'original_total' => $cartTotal,
            'discount_amount' => $discount,
            'final_total' => $finalTotal,
            'abuse_detected' => $discount > $cartTotal ? 'NEGATIVE_TOTAL' : 'NORMAL'
        ];
    }
    
    /**
     * 취약한 주문 처리 (Workflow Bypass)
     * 
     * @param array $orderData 주문 데이터
     * @return array
     */
    public function vulnerableProcessOrder($orderData) {
        // 취약점: 워크플로우 단계 검증 없음
        // 정상 플로우: 장바구니 → 결제 정보 → 주문 확인 → 결제 → 완료
        
        $total = isset($orderData['total']) ? $orderData['total'] : $this->calculateCartTotal();
        $status = isset($orderData['status']) ? $orderData['status'] : 'pending';
        
        // 취약점: 사용자가 주문 상태를 직접 지정 가능
        if ($status === 'completed') {
            // 결제 없이 주문 완료 처리
            $this->balance -= $total;
            
            return [
                'success' => true,
                'message' => '주문이 완료되었습니다.',
                'order_id' => 'ORD-' . time(),
                'total' => $total,
                'status' => $status,
                'bypass_detected' => 'WORKFLOW_BYPASSED',
                'remaining_balance' => $this->balance
            ];
        }
        
        return [
            'success' => true,
            'message' => '주문이 생성되었습니다.',
            'order_id' => 'ORD-' . time(),
            'status' => $status
        ];
    }
    
    /**
     * 취약한 포인트 적립 (Logic Flaw)
     * 
     * @param float $purchaseAmount 구매 금액
     * @param int $multiplier 적립 배수 (사용자 입력)
     * @return array
     */
    public function vulnerableEarnPoints($purchaseAmount, $multiplier = 1) {
        // 취약점: 적립 배수를 사용자가 조작 가능
        // 취약점: 음수 구매 금액으로 포인트 무한 증가 가능
        
        $basePoints = $purchaseAmount * 0.01; // 1% 포인트 적립
        $earnedPoints = $basePoints * $multiplier;
        
        // 취약점: 포인트 상한선 없음
        $totalPoints = $this->getUserPoints() + $earnedPoints;
        
        return [
            'success' => true,
            'purchase_amount' => $purchaseAmount,
            'multiplier' => $multiplier,
            'earned_points' => $earnedPoints,
            'total_points' => $totalPoints,
            'manipulation' => $multiplier > 10 ? 'MULTIPLIER_ABUSE' : 'NORMAL',
            'negative_abuse' => $purchaseAmount < 0 ? 'NEGATIVE_PURCHASE' : 'NORMAL'
        ];
    }
    
    /**
     * 취약한 잔액 이체 (Race Condition Simulation)
     * 
     * @param float $amount 이체 금액
     * @param int $targetUserId 대상 사용자 ID
     * @return array
     */
    public function vulnerableTransferBalance($amount, $targetUserId) {
        // 취약점: 동시성 제어 없음 (Race Condition)
        // 시뮬레이션: 빠른 연속 요청으로 잔액 검증 우회
        
        $currentBalance = $this->balance;
        
        // 취약점: 잔액 확인과 차감 사이에 시간차 존재
        usleep(100000); // 0.1초 지연 (Race Condition 시뮬레이션)
        
        if ($currentBalance >= $amount) {
            $this->balance -= $amount;
            
            return [
                'success' => true,
                'message' => '이체가 완료되었습니다.',
                'transferred_amount' => $amount,
                'remaining_balance' => $this->balance,
                'target_user' => $targetUserId,
                'race_condition_risk' => 'HIGH'
            ];
        }
        
        return [
            'success' => false,
            'message' => '잔액이 부족합니다.',
            'required_amount' => $amount,
            'current_balance' => $currentBalance
        ];
    }
    
    // ==================== 안전한 비즈니스 로직 ====================
    
    /**
     * 안전한 장바구니 추가
     * 
     * @param int $productId 상품 ID
     * @param int $quantity 수량
     * @return array
     */
    public function safeAddToCart($productId, $quantity) {
        // 입력 검증
        if (!is_numeric($productId) || !is_numeric($quantity)) {
            return ['success' => false, 'message' => '잘못된 입력 값입니다.'];
        }
        
        if ($quantity <= 0 || $quantity > 100) {
            return ['success' => false, 'message' => '수량은 1-100 사이여야 합니다.'];
        }
        
        if (!isset($this->products[$productId])) {
            return ['success' => false, 'message' => '존재하지 않는 상품입니다.'];
        }
        
        $product = $this->products[$productId];
        
        // 재고 확인
        if ($quantity > $product['stock']) {
            return ['success' => false, 'message' => '재고가 부족합니다.'];
        }
        
        // 서버에서만 가격 계산
        $totalPrice = $product['price'] * $quantity;
        
        $this->cart[] = [
            'product_id' => $productId,
            'name' => $product['name'],
            'quantity' => $quantity,
            'unit_price' => $product['price'], // 서버 고정 가격
            'total_price' => $totalPrice
        ];
        
        return [
            'success' => true,
            'message' => '장바구니에 추가되었습니다.',
            'cart_total' => $this->calculateCartTotal()
        ];
    }
    
    /**
     * 안전한 할인 적용
     * 
     * @param string $discountCode 할인 코드
     * @return array
     */
    public function safeApplyDiscount($discountCode) {
        // 할인 중복 적용 방지
        if ($this->discountUsed) {
            return ['success' => false, 'message' => '할인은 한 번만 적용 가능합니다.'];
        }
        
        // 유효한 할인 코드 검증
        $validCodes = ['SAVE10' => 10, 'WELCOME20' => 20];
        
        if (!isset($validCodes[$discountCode])) {
            return ['success' => false, 'message' => '잘못된 할인 코드입니다.'];
        }
        
        $discount = $validCodes[$discountCode];
        $cartTotal = $this->calculateCartTotal();
        
        // 할인 후 음수 방지
        $discountedTotal = max(0, $cartTotal - $discount);
        
        $this->discountUsed = true;
        
        return [
            'success' => true,
            'message' => '할인이 적용되었습니다.',
            'original_total' => $cartTotal,
            'discount_amount' => min($discount, $cartTotal),
            'final_total' => $discountedTotal
        ];
    }
    
    /**
     * 안전한 잔액 이체 (동시성 제어)
     * 
     * @param float $amount 이체 금액
     * @param int $targetUserId 대상 사용자 ID
     * @return array
     */
    public function safeTransferBalance($amount, $targetUserId) {
        // 입력 검증
        if (!is_numeric($amount) || $amount <= 0) {
            return ['success' => false, 'message' => '잘못된 이체 금액입니다.'];
        }
        
        if (!is_numeric($targetUserId) || $targetUserId <= 0) {
            return ['success' => false, 'message' => '잘못된 대상 사용자입니다.'];
        }
        
        // 트랜잭션 시뮬레이션 (원자적 연산)
        $lockAcquired = $this->acquireLock('transfer_lock_' . $this->userId);
        
        if (!$lockAcquired) {
            return ['success' => false, 'message' => '처리 중입니다. 잠시 후 다시 시도하세요.'];
        }
        
        try {
            // 잔액 확인 (락 내에서)
            if ($this->balance < $amount) {
                return ['success' => false, 'message' => '잔액이 부족합니다.'];
            }
            
            // 원자적 차감
            $this->balance -= $amount;
            
            return [
                'success' => true,
                'message' => '이체가 완료되었습니다.',
                'transferred_amount' => $amount,
                'remaining_balance' => $this->balance,
                'target_user' => $targetUserId
            ];
            
        } finally {
            $this->releaseLock('transfer_lock_' . $this->userId);
        }
    }
    
    // ==================== 헬퍼 메서드 ====================
    
    private function calculateCartTotal() {
        $total = 0;
        foreach ($this->cart as $item) {
            $total += $item['total_price'];
        }
        return $total;
    }
    
    private function getUserPoints() {
        // 시뮬레이션: 현재 사용자 포인트
        return 150;
    }
    
    private function acquireLock($lockKey) {
        // 시뮬레이션: 락 획득
        return true;
    }
    
    private function releaseLock($lockKey) {
        // 시뮬레이션: 락 해제
        return true;
    }
    
    // ==================== 공용 메서드 ====================
    
    public function getCart() {
        return $this->cart;
    }
    
    public function getBalance() {
        return $this->balance;
    }
    
    public function clearCart() {
        $this->cart = [];
        $this->discountUsed = false;
    }
}