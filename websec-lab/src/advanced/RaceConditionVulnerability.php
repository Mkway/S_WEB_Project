<?php
/**
 * Race Condition Vulnerability Test Module
 * 
 * 동시성 취약점(Race Condition)을 테스트하는 모듈
 * - Bank Transfer Race Condition (은행 이체 경쟁 조건)
 * - File Upload Race Condition (파일 업로드 경쟁 조건)
 * - Session Race Condition (세션 경쟁 조건)
 * - Database Race Condition (데이터베이스 경쟁 조건)
 * - Counter Race Condition (카운터 경쟁 조건)
 */

class RaceConditionVulnerability {
    private $accounts = [];
    private $sessions = [];
    private $counters = [];
    private $fileUploads = [];
    
    // 시뮬레이션을 위한 전역 락 상태
    private static $globalLocks = [];
    
    public function __construct() {
        // 초기 계정 설정
        $this->accounts = [
            'user1' => ['balance' => 1000.00, 'locked' => false],
            'user2' => ['balance' => 500.00, 'locked' => false],
            'user3' => ['balance' => 2000.00, 'locked' => false]
        ];
        
        // 초기 세션 설정
        $this->sessions = [
            'sess_12345' => ['user_id' => 1, 'login_count' => 0, 'locked' => false],
            'sess_67890' => ['user_id' => 2, 'login_count' => 0, 'locked' => false]
        ];
        
        // 초기 카운터 설정
        $this->counters = [
            'page_views' => 1000,
            'download_count' => 500,
            'api_calls' => 2500
        ];
    }
    
    // ==================== 취약한 Race Condition 시나리오 ====================
    
    /**
     * 취약한 은행 이체 (Bank Transfer Race Condition)
     * 
     * @param string $fromAccount 출금 계정
     * @param string $toAccount 입금 계정
     * @param float $amount 이체 금액
     * @return array
     */
    public function vulnerableBankTransfer($fromAccount, $toAccount, $amount) {
        // 취약점: 잔액 확인과 차감 사이에 시간차
        
        if (!isset($this->accounts[$fromAccount]) || !isset($this->accounts[$toAccount])) {
            return ['success' => false, 'message' => '존재하지 않는 계정입니다.'];
        }
        
        // Step 1: 잔액 확인 (여기서 다른 트랜잭션이 끼어들 수 있음)
        $currentBalance = $this->accounts[$fromAccount]['balance'];
        
        // 시뮬레이션: 잔액 확인 후 처리 지연 (Race Condition Window)
        usleep(100000); // 0.1초 지연
        
        // Step 2: 잔액 충분성 검증 (이미 다른 트랜잭션에서 잔액이 변경되었을 수 있음)
        if ($currentBalance >= $amount) {
            
            // Step 3: 더 긴 처리 시간 (추가 Race Condition Window)
            usleep(100000); // 0.1초 추가 지연
            
            // Step 4: 잔액 차감 (원자적이지 않음)
            $this->accounts[$fromAccount]['balance'] -= $amount;
            $this->accounts[$toAccount]['balance'] += $amount;
            
            return [
                'success' => true,
                'message' => '이체가 완료되었습니다.',
                'from_account' => $fromAccount,
                'to_account' => $toAccount,
                'amount' => $amount,
                'from_balance' => $this->accounts[$fromAccount]['balance'],
                'to_balance' => $this->accounts[$toAccount]['balance'],
                'race_condition_window' => '200ms',
                'vulnerability' => 'RACE_CONDITION_DETECTED'
            ];
        }
        
        return [
            'success' => false,
            'message' => '잔액이 부족합니다.',
            'required' => $amount,
            'available' => $currentBalance
        ];
    }
    
    /**
     * 취약한 파일 업로드 경쟁 조건 (File Upload Race Condition)
     * 
     * @param string $filename 파일명
     * @param string $content 파일 내용
     * @return array
     */
    public function vulnerableFileUpload($filename, $content) {
        // 취약점: 파일 검증과 저장 사이의 시간차
        
        $uploadDir = '/tmp/uploads/';
        $filePath = $uploadDir . $filename;
        
        // Step 1: 파일 확장자 검증
        $extension = pathinfo($filename, PATHINFO_EXTENSION);
        $allowedExtensions = ['txt', 'jpg', 'png', 'pdf'];
        
        if (!in_array(strtolower($extension), $allowedExtensions)) {
            return ['success' => false, 'message' => '허용되지 않는 파일 확장자입니다.'];
        }
        
        // Step 2: 파일 크기 검증 (시뮬레이션)
        $fileSize = strlen($content);
        if ($fileSize > 1024 * 1024) { // 1MB 제한
            return ['success' => false, 'message' => '파일 크기가 너무 큽니다.'];
        }
        
        // 취약점: 검증 완료 후 저장 전 시간차 (Race Condition Window)
        usleep(200000); // 0.2초 지연
        
        // Step 3: 파일 저장 (이 시점에 공격자가 파일을 변경할 수 있음)
        $this->fileUploads[$filename] = [
            'content' => $content,
            'size' => $fileSize,
            'upload_time' => time(),
            'validated' => true
        ];
        
        return [
            'success' => true,
            'message' => '파일 업로드가 완료되었습니다.',
            'filename' => $filename,
            'size' => $fileSize,
            'race_window' => '200ms',
            'vulnerability' => 'FILE_RACE_CONDITION'
        ];
    }
    
    /**
     * 취약한 세션 관리 (Session Race Condition)
     * 
     * @param string $sessionId 세션 ID
     * @param string $action 액션 (login/logout)
     * @return array
     */
    public function vulnerableSessionManagement($sessionId, $action) {
        // 취약점: 세션 상태 확인과 변경 사이의 경쟁 조건
        
        if (!isset($this->sessions[$sessionId])) {
            return ['success' => false, 'message' => '유효하지 않은 세션입니다.'];
        }
        
        $session = $this->sessions[$sessionId];
        
        if ($action === 'login') {
            // Step 1: 현재 로그인 카운트 확인
            $currentCount = $session['login_count'];
            
            // 시뮬레이션: 로그인 처리 지연 (Race Condition Window)
            usleep(150000); // 0.15초 지연
            
            // Step 2: 로그인 카운트 증가 (원자적이지 않음)
            $this->sessions[$sessionId]['login_count'] = $currentCount + 1;
            
            return [
                'success' => true,
                'message' => '로그인 처리 완료',
                'session_id' => $sessionId,
                'login_count' => $this->sessions[$sessionId]['login_count'],
                'race_window' => '150ms',
                'vulnerability' => 'SESSION_RACE_CONDITION'
            ];
            
        } elseif ($action === 'logout') {
            // Step 1: 세션 상태 확인
            if ($session['login_count'] <= 0) {
                return ['success' => false, 'message' => '이미 로그아웃 상태입니다.'];
            }
            
            // 시뮬레이션: 로그아웃 처리 지연
            usleep(100000); // 0.1초 지연
            
            // Step 2: 로그아웃 처리 (Race Condition 가능)
            $this->sessions[$sessionId]['login_count'] = 0;
            
            return [
                'success' => true,
                'message' => '로그아웃 처리 완료',
                'session_id' => $sessionId,
                'vulnerability' => 'SESSION_LOGOUT_RACE'
            ];
        }
        
        return ['success' => false, 'message' => '지원하지 않는 액션입니다.'];
    }
    
    /**
     * 취약한 카운터 증가 (Counter Race Condition)
     * 
     * @param string $counterName 카운터 이름
     * @param int $increment 증가값
     * @return array
     */
    public function vulnerableCounterIncrement($counterName, $increment = 1) {
        // 취약점: 읽기-수정-쓰기 과정이 원자적이지 않음
        
        if (!isset($this->counters[$counterName])) {
            return ['success' => false, 'message' => '존재하지 않는 카운터입니다.'];
        }
        
        // Step 1: 현재 값 읽기
        $currentValue = $this->counters[$counterName];
        
        // 시뮬레이션: 계산 처리 시간 (Race Condition Window)
        usleep(50000); // 0.05초 지연
        
        // Step 2: 새 값 계산
        $newValue = $currentValue + $increment;
        
        // 추가 지연 (더 큰 Race Condition Window)
        usleep(50000); // 0.05초 추가 지연
        
        // Step 3: 새 값 저장 (원자적이지 않음)
        $this->counters[$counterName] = $newValue;
        
        return [
            'success' => true,
            'message' => '카운터가 증가되었습니다.',
            'counter_name' => $counterName,
            'previous_value' => $currentValue,
            'new_value' => $newValue,
            'increment' => $increment,
            'race_window' => '100ms',
            'vulnerability' => 'COUNTER_RACE_CONDITION'
        ];
    }
    
    /**
     * 취약한 데이터베이스 업데이트 시뮬레이션 (Database Race Condition)
     * 
     * @param int $recordId 레코드 ID
     * @param array $data 업데이트할 데이터
     * @return array
     */
    public function vulnerableDatabaseUpdate($recordId, $data) {
        // 시뮬레이션: 데이터베이스 레코드
        static $database = [
            1 => ['name' => 'John', 'balance' => 1000, 'version' => 1],
            2 => ['name' => 'Jane', 'balance' => 2000, 'version' => 1],
            3 => ['name' => 'Bob', 'balance' => 500, 'version' => 1]
        ];
        
        if (!isset($database[$recordId])) {
            return ['success' => false, 'message' => '존재하지 않는 레코드입니다.'];
        }
        
        // Step 1: 현재 레코드 읽기 (SELECT)
        $currentRecord = $database[$recordId];
        
        // 시뮬레이션: 데이터베이스 쿼리 지연 (Race Condition Window)
        usleep(200000); // 0.2초 지연
        
        // Step 2: 데이터 수정 (다른 트랜잭션이 이미 수정했을 수 있음)
        foreach ($data as $field => $value) {
            if (isset($currentRecord[$field])) {
                $currentRecord[$field] = $value;
            }
        }
        
        // 추가 처리 지연
        usleep(100000); // 0.1초 지연
        
        // Step 3: 데이터베이스 업데이트 (UPDATE - 원자적이지 않음)
        $database[$recordId] = $currentRecord;
        
        return [
            'success' => true,
            'message' => '데이터베이스 업데이트 완료',
            'record_id' => $recordId,
            'updated_data' => $currentRecord,
            'race_window' => '300ms',
            'vulnerability' => 'DATABASE_RACE_CONDITION'
        ];
    }
    
    // ==================== 안전한 동시성 제어 구현 ====================
    
    /**
     * 안전한 은행 이체 (Lock 기반)
     * 
     * @param string $fromAccount 출금 계정
     * @param string $toAccount 입금 계정
     * @param float $amount 이체 금액
     * @return array
     */
    public function safeBankTransfer($fromAccount, $toAccount, $amount) {
        // 데드락 방지를 위한 계정 정렬 (작은 계정명부터)
        $accounts = [$fromAccount, $toAccount];
        sort($accounts);
        
        // 순서대로 락 획득
        foreach ($accounts as $account) {
            if (!$this->acquireLock("account_$account")) {
                // 락 획득 실패 시 기존 락 해제
                foreach ($accounts as $lockedAccount) {
                    if ($lockedAccount === $account) break;
                    $this->releaseLock("account_$lockedAccount");
                }
                return ['success' => false, 'message' => '처리 중입니다. 잠시 후 다시 시도하세요.'];
            }
        }
        
        try {
            // 원자적 트랜잭션 처리
            if (!isset($this->accounts[$fromAccount]) || !isset($this->accounts[$toAccount])) {
                return ['success' => false, 'message' => '존재하지 않는 계정입니다.'];
            }
            
            if ($this->accounts[$fromAccount]['balance'] < $amount) {
                return ['success' => false, 'message' => '잔액이 부족합니다.'];
            }
            
            // 원자적 업데이트
            $this->accounts[$fromAccount]['balance'] -= $amount;
            $this->accounts[$toAccount]['balance'] += $amount;
            
            return [
                'success' => true,
                'message' => '안전한 이체 완료',
                'from_account' => $fromAccount,
                'to_account' => $toAccount,
                'amount' => $amount,
                'from_balance' => $this->accounts[$fromAccount]['balance'],
                'to_balance' => $this->accounts[$toAccount]['balance'],
                'concurrency_control' => 'LOCK_BASED'
            ];
            
        } finally {
            // 락 해제 (역순으로)
            foreach (array_reverse($accounts) as $account) {
                $this->releaseLock("account_$account");
            }
        }
    }
    
    /**
     * 안전한 카운터 증가 (Atomic Operation)
     * 
     * @param string $counterName 카운터 이름
     * @param int $increment 증가값
     * @return array
     */
    public function safeCounterIncrement($counterName, $increment = 1) {
        if (!isset($this->counters[$counterName])) {
            return ['success' => false, 'message' => '존재하지 않는 카운터입니다.'];
        }
        
        // 락 기반 원자적 증가
        if (!$this->acquireLock("counter_$counterName")) {
            return ['success' => false, 'message' => '카운터가 사용 중입니다.'];
        }
        
        try {
            $oldValue = $this->counters[$counterName];
            $this->counters[$counterName] += $increment; // 원자적 증가
            $newValue = $this->counters[$counterName];
            
            return [
                'success' => true,
                'message' => '안전한 카운터 증가 완료',
                'counter_name' => $counterName,
                'previous_value' => $oldValue,
                'new_value' => $newValue,
                'increment' => $increment,
                'concurrency_control' => 'ATOMIC_OPERATION'
            ];
            
        } finally {
            $this->releaseLock("counter_$counterName");
        }
    }
    
    /**
     * 안전한 데이터베이스 업데이트 (Optimistic Locking)
     * 
     * @param int $recordId 레코드 ID
     * @param array $data 업데이터할 데이터
     * @param int $expectedVersion 예상 버전
     * @return array
     */
    public function safeDatabaseUpdate($recordId, $data, $expectedVersion) {
        static $database = [
            1 => ['name' => 'John', 'balance' => 1000, 'version' => 1],
            2 => ['name' => 'Jane', 'balance' => 2000, 'version' => 1],
            3 => ['name' => 'Bob', 'balance' => 500, 'version' => 1]
        ];
        
        if (!isset($database[$recordId])) {
            return ['success' => false, 'message' => '존재하지 않는 레코드입니다.'];
        }
        
        // Optimistic Locking: 버전 체크
        if ($database[$recordId]['version'] !== $expectedVersion) {
            return [
                'success' => false,
                'message' => '다른 사용자가 이미 수정했습니다. 최신 데이터를 다시 조회하세요.',
                'current_version' => $database[$recordId]['version'],
                'expected_version' => $expectedVersion,
                'conflict_detected' => true
            ];
        }
        
        // 안전한 업데이트
        foreach ($data as $field => $value) {
            if (isset($database[$recordId][$field]) && $field !== 'version') {
                $database[$recordId][$field] = $value;
            }
        }
        
        // 버전 증가
        $database[$recordId]['version']++;
        
        return [
            'success' => true,
            'message' => '안전한 데이터베이스 업데이트 완료',
            'record_id' => $recordId,
            'updated_data' => $database[$recordId],
            'concurrency_control' => 'OPTIMISTIC_LOCKING'
        ];
    }
    
    // ==================== 헬퍼 메서드 ====================
    
    private function acquireLock($lockKey) {
        // 시뮬레이션: 락 획득 시도
        if (isset(self::$globalLocks[$lockKey])) {
            return false; // 이미 락이 잡혀있음
        }
        
        self::$globalLocks[$lockKey] = true;
        return true;
    }
    
    private function releaseLock($lockKey) {
        unset(self::$globalLocks[$lockKey]);
    }
    
    public function getAccounts() {
        return $this->accounts;
    }
    
    public function getCounters() {
        return $this->counters;
    }
    
    public function getSessions() {
        return $this->sessions;
    }
    
    public function getFileUploads() {
        return $this->fileUploads;
    }
}