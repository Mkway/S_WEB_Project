<?php
/**
 * Deserialization Vulnerability Test Module
 * 
 * 역직렬화 취약점을 테스트하는 모듈
 * - PHP Object Injection (PHP 객체 인젝션)
 * - Magic Method Exploitation (__wakeup, __destruct 등)
 * - Property Oriented Programming (POP Chain)
 * - Phar Deserialization (Phar 파일 역직렬화)
 * - Session Deserialization (세션 역직렬화)
 */

/**
 * 취약한 User 클래스 (Magic Method 포함)
 */
class VulnerableUser {
    public $username;
    public $role;
    public $email;
    private $isAdmin = false;
    
    public function __construct($username = '', $role = 'user') {
        $this->username = $username;
        $this->role = $role;
    }
    
    // 취약한 Magic Method: __wakeup (역직렬화 시 자동 실행)
    public function __wakeup() {
        // 취약점: 역직렬화 시 권한 상승 가능
        if ($this->role === 'administrator') {
            $this->isAdmin = true;
            // 위험: 파일 시스템 접근
            file_put_contents('/tmp/admin_access.log', 
                "Admin access granted to: {$this->username} at " . date('Y-m-d H:i:s') . "\n", 
                FILE_APPEND);
        }
    }
    
    // 취약한 Magic Method: __destruct (객체 소멸 시 자동 실행)
    public function __destruct() {
        // 취약점: 객체 소멸 시 임의 파일 삭제 가능
        if ($this->isAdmin && isset($this->email)) {
            // 위험한 파일 삭제 로직
            if (strpos($this->email, 'delete:') === 0) {
                $filename = str_replace('delete:', '', $this->email);
                if (file_exists($filename)) {
                    unlink($filename);
                }
            }
        }
    }
    
    public function getRole() {
        return $this->role;
    }
    
    public function isAdministrator() {
        return $this->isAdmin;
    }
}

/**
 * 취약한 File 클래스 (POP Chain 용)
 */
class VulnerableFile {
    public $filename;
    public $content;
    public $mode;
    
    public function __construct($filename = '', $content = '') {
        $this->filename = $filename;
        $this->content = $content;
        $this->mode = 'read';
    }
    
    // 취약한 Magic Method: __toString (문자열 변환 시 실행)
    public function __toString() {
        // 취약점: 임의 파일 읽기 가능
        if ($this->mode === 'read' && file_exists($this->filename)) {
            return file_get_contents($this->filename);
        }
        return $this->content;
    }
    
    // 취약한 Magic Method: __invoke (객체를 함수처럼 호출 시 실행)
    public function __invoke() {
        // 취약점: 임의 명령 실행 가능
        if ($this->mode === 'exec') {
            return shell_exec($this->content);
        }
        return false;
    }
}

/**
 * 취약한 Cache 클래스 (POP Chain 연결용)
 */
class VulnerableCache {
    public $storage;
    public $key;
    
    public function __construct($storage = null, $key = '') {
        $this->storage = $storage;
        $this->key = $key;
    }
    
    // 취약한 Magic Method: __get (존재하지 않는 속성 접근 시 실행)
    public function __get($name) {
        // 취약점: 연결된 객체의 메서드 자동 실행
        if ($this->storage && method_exists($this->storage, $name)) {
            return $this->storage->$name();
        }
        return null;
    }
    
    // 취약한 Magic Method: __call (존재하지 않는 메서드 호출 시 실행)
    public function __call($name, $arguments) {
        // 취약점: 연결된 객체를 함수로 호출
        if ($this->storage && is_callable($this->storage)) {
            return call_user_func($this->storage);
        }
        return null;
    }
}

class DeserializationVulnerability {
    private $sessionPath = '/tmp/sessions/';
    private $uploadPath = '/tmp/uploads/';
    
    public function __construct() {
        // 디렉토리 생성
        if (!is_dir($this->sessionPath)) {
            mkdir($this->sessionPath, 0777, true);
        }
        if (!is_dir($this->uploadPath)) {
            mkdir($this->uploadPath, 0777, true);
        }
    }
    
    // ==================== 취약한 역직렬화 메서드 ====================
    
    /**
     * 취약한 사용자 데이터 복원 (PHP Object Injection)
     * 
     * @param string $serializedData 직렬화된 사용자 데이터
     * @return array
     */
    public function vulnerableUserRestore($serializedData) {
        try {
            // 취약점: 사용자 입력을 검증 없이 역직렬화
            $user = unserialize($serializedData);
            
            if ($user instanceof VulnerableUser) {
                return [
                    'success' => true,
                    'message' => '사용자 데이터 복원 성공',
                    'username' => $user->username,
                    'role' => $user->getRole(),
                    'is_admin' => $user->isAdministrator(),
                    'vulnerability' => 'PHP_OBJECT_INJECTION',
                    'magic_methods_executed' => '__wakeup() 자동 실행됨'
                ];
            }
            
            return [
                'success' => false,
                'message' => '잘못된 사용자 객체',
                'received_class' => get_class($user)
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => '역직렬화 실패: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * 취약한 세션 데이터 처리 (Session Deserialization)
     * 
     * @param string $sessionId 세션 ID
     * @param string $sessionData 세션 데이터
     * @return array
     */
    public function vulnerableSessionHandle($sessionId, $sessionData) {
        $sessionFile = $this->sessionPath . 'sess_' . $sessionId;
        
        // 세션 데이터 저장
        file_put_contents($sessionFile, $sessionData);
        
        try {
            // 취약점: 세션 데이터를 검증 없이 역직렬화
            $data = unserialize($sessionData);
            
            return [
                'success' => true,
                'message' => '세션 데이터 처리 완료',
                'session_id' => $sessionId,
                'data_type' => gettype($data),
                'data_class' => is_object($data) ? get_class($data) : 'N/A',
                'vulnerability' => 'SESSION_DESERIALIZATION',
                'session_file' => $sessionFile
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => '세션 처리 실패: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * 취약한 캐시 데이터 로드 (Property Oriented Programming)
     * 
     * @param string $cacheKey 캐시 키
     * @param string $cacheData 캐시 데이터 (직렬화됨)
     * @return array
     */
    public function vulnerableCacheLoad($cacheKey, $cacheData) {
        try {
            // 취약점: POP Chain 공격 가능한 역직렬화
            $cache = unserialize($cacheData);
            
            // 취약한 속성 접근 (Magic Method __get 트리거)
            $result = [];
            if (is_object($cache)) {
                $result['object_class'] = get_class($cache);
                
                // 취약점: Magic Method 트리거
                if (property_exists($cache, 'key')) {
                    $result['cache_key'] = $cache->key;
                }
                
                // __get Magic Method 트리거
                $result['auto_property'] = $cache->autoExecute ?? 'N/A';
                
                // __call Magic Method 트리거 (존재하지 않는 메서드 호출)
                if (method_exists($cache, '__call')) {
                    $result['call_result'] = $cache->triggerExecution();
                }
            }
            
            return [
                'success' => true,
                'message' => 'POP Chain 실행 완료',
                'cache_key' => $cacheKey,
                'result' => $result,
                'vulnerability' => 'POP_CHAIN_EXPLOITATION'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => 'POP Chain 실행 실패: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * 취약한 Phar 파일 처리 (Phar Deserialization)
     * 
     * @param string $pharPath Phar 파일 경로
     * @return array
     */
    public function vulnerablePharProcess($pharPath) {
        try {
            // 취약점: Phar 스트림 래퍼를 통한 자동 역직렬화
            // phar:// 스트림 사용 시 메타데이터가 자동 역직렬화됨
            
            if (file_exists($pharPath)) {
                // 위험한 Phar 파일 접근
                $pharInfo = file_get_contents("phar://$pharPath/dummy.txt");
                
                return [
                    'success' => true,
                    'message' => 'Phar 파일 처리 완료',
                    'phar_path' => $pharPath,
                    'content_length' => strlen($pharInfo),
                    'vulnerability' => 'PHAR_DESERIALIZATION',
                    'warning' => 'Phar 메타데이터 자동 역직렬화 발생'
                ];
            }
            
            return [
                'success' => false,
                'message' => 'Phar 파일을 찾을 수 없습니다.'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => 'Phar 처리 실패: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * 취약한 쿠키 데이터 처리
     * 
     * @param string $cookieData 쿠키 데이터 (Base64 인코딩된 직렬화 데이터)
     * @return array
     */
    public function vulnerableCookieProcess($cookieData) {
        try {
            // Base64 디코딩
            $decodedData = base64_decode($cookieData);
            
            // 취약점: 쿠키 데이터를 검증 없이 역직렬화
            $userData = unserialize($decodedData);
            
            $result = [
                'success' => true,
                'message' => '쿠키 데이터 처리 완료',
                'data_type' => gettype($userData),
                'vulnerability' => 'COOKIE_DESERIALIZATION'
            ];
            
            if (is_object($userData)) {
                $result['object_class'] = get_class($userData);
                $result['magic_methods'] = '역직렬화 시 자동 실행됨';
            } elseif (is_array($userData)) {
                $result['array_keys'] = array_keys($userData);
            }
            
            return $result;
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => '쿠키 처리 실패: ' . $e->getMessage()
            ];
        }
    }
    
    // ==================== 안전한 역직렬화 구현 ====================
    
    /**
     * 안전한 사용자 데이터 복원 (화이트리스트 기반)
     * 
     * @param string $serializedData 직렬화된 데이터
     * @param array $allowedClasses 허용된 클래스 목록
     * @return array
     */
    public function safeUserRestore($serializedData, $allowedClasses = []) {
        try {
            // 안전한 역직렬화: 허용된 클래스만 역직렬화
            $options = [
                'allowed_classes' => $allowedClasses
            ];
            
            $user = unserialize($serializedData, $options);
            
            // 추가 검증
            if (!in_array(get_class($user), $allowedClasses)) {
                return [
                    'success' => false,
                    'message' => '허용되지 않는 클래스입니다.',
                    'class' => get_class($user)
                ];
            }
            
            // 데이터 무결성 검증
            if ($user instanceof VulnerableUser) {
                // 권한 검증
                if ($user->getRole() === 'administrator') {
                    // 관리자 권한 재검증 필요
                    return [
                        'success' => false,
                        'message' => '관리자 권한은 별도 인증이 필요합니다.',
                        'security' => 'PRIVILEGE_ESCALATION_BLOCKED'
                    ];
                }
            }
            
            return [
                'success' => true,
                'message' => '안전한 사용자 데이터 복원',
                'username' => $user->username,
                'role' => $user->getRole(),
                'security' => 'WHITELIST_VALIDATION'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => '안전한 역직렬화 실패: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * 안전한 세션 데이터 처리 (JSON 기반)
     * 
     * @param string $sessionId 세션 ID
     * @param string $jsonData JSON 세션 데이터
     * @return array
     */
    public function safeSessionHandle($sessionId, $jsonData) {
        try {
            // 안전한 데이터 형식: JSON 사용
            $data = json_decode($jsonData, true);
            
            if (json_last_error() !== JSON_ERROR_NONE) {
                return [
                    'success' => false,
                    'message' => 'JSON 파싱 실패: ' . json_last_error_msg()
                ];
            }
            
            // 데이터 구조 검증
            $requiredFields = ['user_id', 'username', 'role'];
            foreach ($requiredFields as $field) {
                if (!isset($data[$field])) {
                    return [
                        'success' => false,
                        'message' => "필수 필드 누락: $field"
                    ];
                }
            }
            
            // 세션 파일 저장 (JSON 형태)
            $sessionFile = $this->sessionPath . 'safe_sess_' . $sessionId;
            file_put_contents($sessionFile, $jsonData);
            
            return [
                'success' => true,
                'message' => '안전한 세션 처리 완료',
                'session_id' => $sessionId,
                'user_id' => $data['user_id'],
                'username' => $data['username'],
                'role' => $data['role'],
                'security' => 'JSON_FORMAT',
                'session_file' => $sessionFile
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => '안전한 세션 처리 실패: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * 안전한 데이터 서명 검증
     * 
     * @param string $data 데이터
     * @param string $signature 서명
     * @param string $secretKey 비밀 키
     * @return array
     */
    public function safeDataWithSignature($data, $signature, $secretKey = 'secret_key_123') {
        // HMAC 서명 검증
        $expectedSignature = hash_hmac('sha256', $data, $secretKey);
        
        if (!hash_equals($expectedSignature, $signature)) {
            return [
                'success' => false,
                'message' => '데이터 서명이 유효하지 않습니다.',
                'security' => 'SIGNATURE_VERIFICATION_FAILED'
            ];
        }
        
        try {
            $decodedData = base64_decode($data);
            $parsedData = json_decode($decodedData, true);
            
            return [
                'success' => true,
                'message' => '서명 검증 및 데이터 처리 완료',
                'data' => $parsedData,
                'security' => 'HMAC_SIGNATURE_VERIFIED'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => '데이터 처리 실패: ' . $e->getMessage()
            ];
        }
    }
    
    // ==================== 헬퍼 메서드 ====================
    
    /**
     * 악성 직렬화 데이터 생성 (테스트용)
     * 
     * @param string $type 공격 유형
     * @return string
     */
    public function createMaliciousPayload($type) {
        switch ($type) {
            case 'admin_escalation':
                $user = new VulnerableUser('hacker', 'administrator');
                $user->email = 'delete:/tmp/important_file.txt';
                return serialize($user);
                
            case 'pop_chain':
                $file = new VulnerableFile('/etc/passwd', 'cat /etc/passwd');
                $file->mode = 'read';
                $cache = new VulnerableCache($file, 'malicious_key');
                return serialize($cache);
                
            case 'command_execution':
                $file = new VulnerableFile('', 'whoami');
                $file->mode = 'exec';
                $cache = new VulnerableCache($file);
                return serialize($cache);
                
            default:
                $user = new VulnerableUser('test_user', 'user');
                return serialize($user);
        }
    }
}