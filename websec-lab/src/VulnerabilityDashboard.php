<?php
class VulnerabilityDashboard {
    private $db;
    
    public function __construct($db) {
        $this->db = $db;
        $this->initializeDashboardDatabase();
    }
    
    private function initializeDashboardDatabase() {
        // 대시보드용 테이블 생성
        $tables = [
            "CREATE TABLE IF NOT EXISTS dashboard_tests (
                id INT AUTO_INCREMENT PRIMARY KEY,
                test_name VARCHAR(100) NOT NULL,
                test_category VARCHAR(50) NOT NULL,
                test_file VARCHAR(200) NOT NULL,
                description TEXT,
                difficulty ENUM('basic', 'intermediate', 'advanced') DEFAULT 'basic',
                status ENUM('available', 'maintenance', 'deprecated') DEFAULT 'available',
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                test_count INT DEFAULT 0
            )",
            "CREATE TABLE IF NOT EXISTS dashboard_results (
                id INT AUTO_INCREMENT PRIMARY KEY,
                test_name VARCHAR(100) NOT NULL,
                result_type ENUM('vulnerable', 'safe', 'error') NOT NULL,
                execution_time DECIMAL(8,3) DEFAULT 0.000,
                payload_used TEXT,
                result_data LONGTEXT,
                user_agent VARCHAR(255),
                ip_address VARCHAR(45),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )",
            "CREATE TABLE IF NOT EXISTS dashboard_stats (
                id INT AUTO_INCREMENT PRIMARY KEY,
                stat_date DATE NOT NULL,
                total_tests INT DEFAULT 0,
                vulnerable_results INT DEFAULT 0,
                safe_results INT DEFAULT 0,
                error_results INT DEFAULT 0,
                unique_visitors INT DEFAULT 0,
                UNIQUE KEY unique_date (stat_date)
            )"
        ];
        
        foreach ($tables as $sql) {
            $this->db->exec($sql);
        }
        
        // 기본 테스트 데이터 삽입
        $this->initializeTestData();
    }
    
    private function initializeTestData() {
        $tests = [
            // 기본 취약점
            ['SQL Injection', 'Web Application', 'webhacking/sql_injection.php', 'SQL 쿼리 주입을 통한 데이터베이스 조작', 'basic'],
            ['XSS (Cross-Site Scripting)', 'Web Application', 'webhacking/xss_test.php', '악성 스크립트 주입을 통한 사용자 공격', 'basic'],
            ['Command Injection', 'System', 'webhacking/command_injection.php', '시스템 명령어 주입을 통한 서버 제어', 'basic'],
            ['File Upload Vulnerability', 'File System', 'webhacking/file_upload_test.php', '위험한 파일 업로드를 통한 서버 장악', 'basic'],
            ['CSRF Attack', 'Web Application', 'webhacking/csrf_test.php', '사용자 권한을 악용한 요청 위조', 'basic'],
            ['Directory Traversal', 'File System', 'webhacking/directory_traversal.php', '경로 순회를 통한 시스템 파일 접근', 'basic'],
            ['File Inclusion (LFI/RFI)', 'File System', 'webhacking/file_inclusion.php', '파일 포함을 통한 코드 실행', 'basic'],
            ['Authentication Bypass', 'Authentication', 'webhacking/auth_bypass.php', '인증 우회를 통한 권한 상승', 'basic'],
            
            // 중간 우선순위
            ['XXE (XML External Entity)', 'XML Processing', 'webhacking/xxe_test.php', 'XML 외부 엔티티를 통한 정보 유출', 'intermediate'],
            ['SSRF (Server-Side Request Forgery)', 'Network', 'webhacking/ssrf_test.php', '서버측 요청 위조를 통한 내부망 접근', 'intermediate'],
            ['SSTI (Server-Side Template Injection)', 'Template Engine', 'webhacking/ssti_test.php', '템플릿 엔진 취약점을 통한 코드 실행', 'intermediate'],
            ['Open Redirect', 'Web Application', 'webhacking/open_redirect_test.php', '오픈 리다이렉트를 통한 피싱 공격', 'intermediate'],
            ['XPath Injection', 'XML Processing', 'webhacking/xpath_test.php', 'XPath 쿼리 조작을 통한 데이터 추출', 'intermediate'],
            
            // 고급 환경
            ['NoSQL Injection', 'Database', 'webhacking/nosql_injection_test.php', 'NoSQL 데이터베이스 조작 및 우회', 'advanced'],
            ['Cache Injection', 'Caching System', 'webhacking/redis_cache_injection.php', 'Redis 캐시 조작 및 데이터 오염', 'advanced'],
            ['Java Deserialization', 'Serialization', '../node_app/index.html', 'Java 객체 직렬화를 통한 RCE', 'advanced'],
            
            // Advanced 모듈
            ['Business Logic Vulnerability', 'Business Logic', 'webhacking/business_logic.php', '비즈니스 로직 취약점을 통한 우회', 'advanced'],
            ['Race Condition', 'Concurrency', 'webhacking/race_condition.php', '동시성 취약점을 통한 데이터 조작', 'advanced'],
            ['Advanced Deserialization', 'Serialization', 'webhacking/advanced_deserialization.php', '다양한 언어의 직렬화 취약점', 'advanced'],
            
            // API Security Testing
            ['API Security Testing', 'API Security', 'webhacking/api_security.php', 'REST API, GraphQL, JWT 등 API 보안 종합 테스트', 'advanced']
        ];
        
        $stmt = $this->db->prepare("INSERT IGNORE INTO dashboard_tests (test_name, test_category, test_file, description, difficulty) VALUES (?, ?, ?, ?, ?)");
        
        foreach ($tests as $test) {
            $stmt->execute($test);
        }
    }
    
    public function getAllTests() {
        $stmt = $this->db->prepare("SELECT * FROM dashboard_tests WHERE status = 'available' ORDER BY 
            FIELD(difficulty, 'basic', 'intermediate', 'advanced'), test_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    public function getTestsByCategory() {
        $stmt = $this->db->prepare("SELECT test_category, COUNT(*) as count FROM dashboard_tests WHERE status = 'available' GROUP BY test_category ORDER BY count DESC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    public function getDashboardStats() {
        $stats = [];
        
        // 총 테스트 수
        $stmt = $this->db->prepare("SELECT COUNT(*) as total_tests FROM dashboard_tests WHERE status = 'available'");
        $stmt->execute();
        $stats['total_tests'] = $stmt->fetch(PDO::FETCH_ASSOC)['total_tests'];
        
        // 난이도별 분포
        $stmt = $this->db->prepare("SELECT difficulty, COUNT(*) as count FROM dashboard_tests WHERE status = 'available' GROUP BY difficulty");
        $stmt->execute();
        $difficulty_stats = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
        $stats['basic'] = 0;
        $stats['intermediate'] = 0;
        $stats['advanced'] = 0;
        
        foreach ($difficulty_stats as $stat) {
            $stats[$stat['difficulty']] = $stat['count'];
        }
        
        // 최근 30일간 테스트 결과 통계
        $stmt = $this->db->prepare("SELECT 
            COUNT(*) as total_results,
            SUM(CASE WHEN result_type = 'vulnerable' THEN 1 ELSE 0 END) as vulnerable_count,
            SUM(CASE WHEN result_type = 'safe' THEN 1 ELSE 0 END) as safe_count,
            SUM(CASE WHEN result_type = 'error' THEN 1 ELSE 0 END) as error_count
            FROM dashboard_results 
            WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)");
        $stmt->execute();
        $result_stats = $stmt->fetch(PDO::FETCH_ASSOC);
        
        $stats = array_merge($stats, $result_stats);
        
        return $stats;
    }
    
    public function logTestResult($test_name, $result_type, $execution_time, $payload_used = '', $result_data = '') {
        $stmt = $this->db->prepare("INSERT INTO dashboard_results 
            (test_name, result_type, execution_time, payload_used, result_data, user_agent, ip_address) 
            VALUES (?, ?, ?, ?, ?, ?, ?)");
            
        $user_agent = $_SERVER['HTTP_USER_AGENT'] ?? 'Unknown';
        $ip_address = $_SERVER['REMOTE_ADDR'] ?? 'Unknown';
        
        $stmt->execute([$test_name, $result_type, $execution_time, $payload_used, $result_data, $user_agent, $ip_address]);
        
        // 테스트 카운트 증가
        $stmt = $this->db->prepare("UPDATE dashboard_tests SET test_count = test_count + 1 WHERE test_name = ?");
        $stmt->execute([$test_name]);
    }
    
    public function getRecentResults($limit = 10) {
        $stmt = $this->db->prepare("SELECT test_name, result_type, execution_time, created_at 
            FROM dashboard_results 
            ORDER BY created_at DESC 
            LIMIT ?");
        $stmt->execute([$limit]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    public function executeVulnerabilityTest($test_file, $payload = '') {
        $start_time = microtime(true);
        $result = [];
        
        try {
            $file_path = __DIR__ . '/' . $test_file;
            
            if (!file_exists($file_path)) {
                throw new Exception("테스트 파일을 찾을 수 없습니다: $test_file");
            }
            
            // 대신 파일 URL로 리다이렉트하는 방식으로 변경
            $execution_time = microtime(true) - $start_time;
            
            // 테스트 파일의 웹 경로 생성
            $web_path = str_replace(__DIR__ . '/', '', $file_path);
            $web_url = '/' . $web_path;
            
            $result = [
                'success' => true,
                'redirect_url' => $web_url,
                'execution_time' => round($execution_time * 1000, 3),
                'message' => '테스트 페이지로 이동합니다.'
            ];
            
        } catch (Exception $e) {
            $execution_time = microtime(true) - $start_time;
            
            $result = [
                'success' => false,
                'output' => '',
                'execution_time' => round($execution_time * 1000, 3),
                'message' => '테스트 실행 중 오류 발생: ' . $e->getMessage()
            ];
        }
        
        return $result;
    }
    
    public function generateVulnerabilityReport($test_name = '', $date_from = '', $date_to = '') {
        $where_conditions = [];
        $params = [];
        
        if (!empty($test_name)) {
            $where_conditions[] = "test_name = ?";
            $params[] = $test_name;
        }
        
        if (!empty($date_from)) {
            $where_conditions[] = "created_at >= ?";
            $params[] = $date_from . ' 00:00:00';
        }
        
        if (!empty($date_to)) {
            $where_conditions[] = "created_at <= ?";
            $params[] = $date_to . ' 23:59:59';
        }
        
        $where_sql = !empty($where_conditions) ? 'WHERE ' . implode(' AND ', $where_conditions) : '';
        
        $sql = "SELECT 
            test_name,
            result_type,
            COUNT(*) as count,
            AVG(execution_time) as avg_execution_time,
            MIN(created_at) as first_test,
            MAX(created_at) as last_test
            FROM dashboard_results 
            $where_sql
            GROUP BY test_name, result_type 
            ORDER BY test_name, result_type";
            
        $stmt = $this->db->prepare($sql);
        $stmt->execute($params);
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}
?>