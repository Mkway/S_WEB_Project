#!/bin/bash

# ==============================================
# S_WEB_Project 취약점 테스트 자동화 스크립트
# ==============================================

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# 프로젝트 설정
PROJECT_ROOT="/home/wsl/S_WEB_Project"
WEBSEC_LAB_DIR="$PROJECT_ROOT/websec-lab/src/webhacking"
TEST_LOG="$PROJECT_ROOT/log/test_results_$(date +%Y%m%d_%H%M%S).log"

# 로깅 함수
log_test() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$TEST_LOG"
}

# 메시지 출력 함수들
show_test_progress() {
    echo -e "${BLUE}🧪 $1${NC}"
    log_test "TEST_PROGRESS: $1"
}

show_test_success() {
    echo -e "${GREEN}✅ $1${NC}"
    log_test "TEST_SUCCESS: $1"
}

show_test_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
    log_test "TEST_WARNING: $1"
}

show_test_error() {
    echo -e "${RED}❌ $1${NC}"
    log_test "TEST_ERROR: $1"
}

# 메인 테스트 함수
main() {
    echo -e "${PURPLE}"
    echo "=================================================="
    echo "🧪 S_WEB_Project 취약점 테스트 자동화"
    echo "=================================================="
    echo -e "${NC}"
    
    # 로그 디렉토리 생성
    mkdir -p "$(dirname "$TEST_LOG")"
    log_test "테스트 시작"
    
    # 인자로 받은 취약점 타입 확인
    if [[ $# -eq 1 ]]; then
        test_specific_vulnerability "$1"
    else
        test_all_vulnerabilities
    fi
}

# 특정 취약점 테스트
test_specific_vulnerability() {
    local vuln_type="$1"
    local test_file="$WEBSEC_LAB_DIR/${vuln_type}_test.php"
    
    show_test_progress "[$vuln_type] 테스트 시작"
    
    if [[ ! -f "$test_file" ]]; then
        show_test_error "테스트 파일을 찾을 수 없습니다: $test_file"
        return 1
    fi
    
    # PHP 구문 검사
    run_syntax_check "$test_file" "$vuln_type"
    
    # 코드 품질 검사
    run_code_quality_check "$test_file" "$vuln_type"
    
    # 보안 패턴 검사
    run_security_pattern_check "$test_file" "$vuln_type"
    
    # 실제 실행 확인
    check_real_execution_implementation "$test_file" "$vuln_type"
    
    show_test_success "[$vuln_type] 모든 테스트 완료"
}

# 전체 취약점 테스트
test_all_vulnerabilities() {
    show_test_progress "전체 취약점 테스트 실행"
    
    local vulnerabilities=("xxe" "ssrf" "ssti" "open_redirect" "xpath")
    local failed_tests=()
    
    for vuln in "${vulnerabilities[@]}"; do
        echo ""
        if test_specific_vulnerability "$vuln"; then
            show_test_success "[$vuln] 테스트 통과"
        else
            show_test_error "[$vuln] 테스트 실패"
            failed_tests+=("$vuln")
        fi
    done
    
    # 결과 요약
    echo ""
    echo -e "${PURPLE}📊 테스트 결과 요약${NC}"
    echo "=================================================="
    
    if [[ ${#failed_tests[@]} -eq 0 ]]; then
        show_test_success "모든 취약점 테스트 통과!"
    else
        show_test_warning "실패한 테스트: ${failed_tests[*]}"
    fi
}

# PHP 구문 검사
run_syntax_check() {
    local file="$1"
    local vuln_type="$2"
    
    show_test_progress "[$vuln_type] PHP 구문 검사"
    
    if command -v php &> /dev/null; then
        if php -l "$file" &> /dev/null; then
            show_test_success "[$vuln_type] PHP 구문 검사 통과"
            return 0
        else
            show_test_error "[$vuln_type] PHP 구문 오류 발견"
            php -l "$file"
            return 1
        fi
    else
        show_test_warning "[$vuln_type] PHP가 설치되지 않아 구문 검사 건너뜀"
        return 0
    fi
}

# 코드 품질 검사
run_code_quality_check() {
    local file="$1"
    local vuln_type="$2"
    
    show_test_progress "[$vuln_type] 코드 품질 검사"
    
    local issues=()
    
    # 기본적인 패턴 검사
    if ! grep -q "<?php" "$file"; then
        issues+=("PHP 오프닝 태그 누락")
    fi
    
    if ! grep -q "TestPage" "$file"; then
        issues+=("TestPage 클래스 사용 확인 필요")
    fi
    
    if ! grep -q "payloads" "$file"; then
        issues+=("페이로드 정의 확인 필요")
    fi
    
    if ! grep -q "defense_methods\|방어\|보안" "$file"; then
        issues+=("보안 권장사항 섹션 확인 필요")
    fi
    
    if [[ ${#issues[@]} -eq 0 ]]; then
        show_test_success "[$vuln_type] 코드 품질 검사 통과"
        return 0
    else
        show_test_warning "[$vuln_type] 코드 품질 이슈:"
        for issue in "${issues[@]}"; do
            echo "    - $issue"
        done
        return 1
    fi
}

# 보안 패턴 검사
run_security_pattern_check() {
    local file="$1"
    local vuln_type="$2"
    
    show_test_progress "[$vuln_type] 보안 패턴 검사"
    
    local security_issues=()
    
    # 위험한 함수 사용 확인
    if grep -q "eval\|exec\|system\|shell_exec" "$file"; then
        if ! grep -q "교육\|학습\|테스트" "$file"; then
            security_issues+=("위험한 함수 사용 시 교육 목적 명시 필요")
        fi
    fi
    
    # 사용자 입력 처리 확인
    if grep -q "\$_GET\|\$_POST\|\$_REQUEST" "$file"; then
        if ! grep -q "htmlspecialchars\|filter_input\|validation" "$file"; then
            security_issues+=("사용자 입력 검증/이스케이프 확인 필요")
        fi
    fi
    
    if [[ ${#security_issues[@]} -eq 0 ]]; then
        show_test_success "[$vuln_type] 보안 패턴 검사 통과"
        return 0
    else
        show_test_warning "[$vuln_type] 보안 패턴 이슈:"
        for issue in "${security_issues[@]}"; do
            echo "    - $issue"
        done
        return 1
    fi
}

# 실제 실행 구현 확인
check_real_execution_implementation() {
    local file="$1"
    local vuln_type="$2"
    
    show_test_progress "[$vuln_type] 실제 실행 구현 확인"
    
    local implementation_score=0
    local max_score=4
    
    # 1. 시뮬레이션 모드 제거 확인
    if ! grep -q "시뮬레이션\|simulation\|가상\|fake" "$file"; then
        ((implementation_score++))
        log_test "[$vuln_type] ✓ 시뮬레이션 모드 제거됨"
    else
        log_test "[$vuln_type] ✗ 아직 시뮬레이션 모드 포함"
    fi
    
    # 2. 실제 실행 코드 확인
    case "$vuln_type" in
        "xxe")
            if grep -q "file_get_contents\|simplexml_load_string\|DOMDocument" "$file"; then
                ((implementation_score++))
                log_test "[$vuln_type] ✓ 실제 XML 파싱 코드 존재"
            fi
            ;;
        "ssrf")
            if grep -q "curl\|file_get_contents.*http\|stream_context_create" "$file"; then
                ((implementation_score++))
                log_test "[$vuln_type] ✓ 실제 HTTP 요청 코드 존재"
            fi
            ;;
        "ssti")
            if grep -q "Twig\|Smarty\|eval\|render" "$file"; then
                ((implementation_score++))
                log_test "[$vuln_type] ✓ 템플릿 엔진 코드 존재"
            fi
            ;;
    esac
    
    # 3. 결과 비교 구현 확인
    if grep -q "vulnerable.*output\|safe.*comparison\|취약한.*안전한" "$file"; then
        ((implementation_score++))
        log_test "[$vuln_type] ✓ 취약한 vs 안전한 구현 비교 존재"
    fi
    
    # 4. 컬러 코딩 확인
    if grep -q "class.*vulnerable\|class.*safe\|color.*red\|color.*green" "$file"; then
        ((implementation_score++))
        log_test "[$vuln_type] ✓ 컬러 코딩 구현 존재"
    fi
    
    # 결과 평가
    local percentage=$((implementation_score * 100 / max_score))
    
    if [[ $percentage -ge 75 ]]; then
        show_test_success "[$vuln_type] 실제 실행 구현 완료도: ${percentage}%"
        return 0
    elif [[ $percentage -ge 50 ]]; then
        show_test_warning "[$vuln_type] 실제 실행 구현 진행 중: ${percentage}%"
        return 1
    else
        show_test_error "[$vuln_type] 실제 실행 구현 필요: ${percentage}%"
        return 1
    fi
}

# 스크립트 권한 확인 및 실행
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi